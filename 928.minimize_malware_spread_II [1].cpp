class Solution {
private:
    void bfs(vector<vector<int>>& graph, vector<bool>& visited, int src, int skip){
        // source node itself is to be skipped
        if(src == skip)
            return;

        queue<int> q;
        visited[src] = true;
        q.push(src);

        while(!q.empty())
        {
            int curr = q.front();
            q.pop();

            for(int nei: graph[curr])
            {
                if(visited[nei] || nei == skip)
                    continue;

                visited[nei] = true;
                q.push(nei);
            }
        }
    }

public:
    // T.C.=O(V*(V + E)), S.C.=O(V + E)
    // V: num of vertices (here, n), E: num of edges
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // only 1 infected node, so it is the only one than can be removed
        if(initial.size() == 1)
            return initial[0];

        // build graph (adjacency-list)
        int n=graph.size();
        vector<vector<int>> adj(n);

        for(int i=0; i<n; i++)
            for(int j=0; j<n; j++)
                if(i != j && graph[i][j] == 1)
                    adj[i].push_back(j);

        // sort the infected nodes to get the 
        // one with smallest index in case of tie-break
        sort(initial.begin(), initial.end());
        // infected node to be removed in order to 
        // minimize the final infected count
        int removedNode = initial[0];
        // min num of finally infected nodes 
        int minFinalInfected = n;

        for(int skip: initial)
        {
            vector<bool> visited(n, false);

            // multi-source BFS starting at each 
            // non-visited infected node
            for(int src: initial)
                if(!visited[src])
                    bfs(adj, visited, src, skip);

            // num of finally infected nodes, 
            // when the infected node 'skip' is skipped
            int finalInfected = 0;

            for(int i=0; i<n; i++)
                if(visited[i])
                    finalInfected++;
            
            // skipping the 'skip' node has minimized the final infections
            if(finalInfected < minFinalInfected)
            {
                minFinalInfected = finalInfected;
                removedNode = skip;
            }
        }

        return removedNode;
    }
};