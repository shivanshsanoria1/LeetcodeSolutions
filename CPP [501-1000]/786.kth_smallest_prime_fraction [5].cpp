class Solution {
private:
    // {arr[i]/arr[j], {i, j}}
    typedef pair<float, pair<int, int>> PFII;

public:
    // T.C.=O(n*logn + k*logn), S.C.=O(n)
    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
        int n=arr.size();
        // min-heap
        priority_queue<PFII, vector<PFII>, greater<PFII>> pq; 

        // smallest fractions can be generated by dividing 
        // each numerator with the largest denominator
        for(int i=0; i<n; i++)
            pq.push({(float)arr[i] / arr[n-1], {i, n-1}});
        
        // pop (k-1) elements from the heap and each time, push the 
        // fraction formed with the same numerator and the next smallest denominator
        while(--k)
        {
            auto [i, j] = pq.top().second;
            pq.pop();

            pq.push({(float)arr[i] / arr[j-1], {i, j-1}});
        }

        auto [i, j] = pq.top().second;
        
        vector<int> ans(2, 0);
        ans[0] = arr[i];
        ans[1] = arr[j];

        return ans;
    }
};